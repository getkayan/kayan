package session

import (
	"fmt"
	"time"

	"github.com/getkayan/kayan/domain"
	"github.com/getkayan/kayan/identity"
	"github.com/golang-jwt/jwt/v5"
)

type Session = identity.Session

// Strategy defines the interface for session management strategies.
type Strategy interface {
	Create(sessionID, identityID any) (*identity.Session, error)
	Validate(sessionID any) (*identity.Session, error)
	Delete(sessionID any) error
}

// DatabaseStrategy implements the session strategy using a database.
type DatabaseStrategy struct {
	repo domain.SessionStorage
}

func NewDatabaseStrategy(repo domain.SessionStorage) *DatabaseStrategy {
	return &DatabaseStrategy{repo: repo}
}

func (s *DatabaseStrategy) Create(sessionID, identityID any) (*identity.Session, error) {
	sess := NewSession(sessionID, identityID)
	if err := s.repo.CreateSession(sess); err != nil {
		return nil, err
	}
	return sess, nil
}

func (s *DatabaseStrategy) Validate(sessionID any) (*identity.Session, error) {
	sess, err := s.repo.GetSession(sessionID)
	if err != nil {
		return nil, err
	}

	if !sess.Active || sess.ExpiresAt.Before(time.Now()) {
		return nil, fmt.Errorf("session expired or inactive")
	}

	return sess, nil
}

func (s *DatabaseStrategy) Delete(sessionID any) error {
	return s.repo.DeleteSession(sessionID)
}

// JWTConfig holds the configuration for JWT-based sessions.
type JWTConfig struct {
	SigningMethod jwt.SigningMethod
	SigningKey    any // e.g., []byte for HMAC, *rsa.PrivateKey for RSA
	VerifyingKey  any // e.g., []byte for HMAC (same as SigningKey), *rsa.PublicKey for RSA
	Expiry        time.Duration
}

// JWTStrategy implements the session strategy using JSON Web Tokens.
type JWTStrategy struct {
	config JWTConfig
}

// NewJWTStrategy creates a new JWT strategy with the given configuration.
func NewJWTStrategy(config JWTConfig) *JWTStrategy {
	return &JWTStrategy{config: config}
}

// NewHS256Strategy is a convenience constructor for HS256 strategy.
func NewHS256Strategy(secret string, expiry time.Duration) *JWTStrategy {
	return &JWTStrategy{
		config: JWTConfig{
			SigningMethod: jwt.SigningMethodHS256,
			SigningKey:    []byte(secret),
			VerifyingKey:  []byte(secret),
			Expiry:        expiry,
		},
	}
}

// JWTClaims represents the data stored in the JWT.
type JWTClaims struct {
	SessionID string `json:"sid"`
	jwt.RegisteredClaims
}

func (s *JWTStrategy) Create(sessionID, identityID any) (*identity.Session, error) {
	now := time.Now()
	expiresAt := now.Add(s.config.Expiry)

	claims := JWTClaims{
		SessionID: fmt.Sprintf("%v", sessionID),
		RegisteredClaims: jwt.RegisteredClaims{
			Subject:   fmt.Sprintf("%v", identityID),
			ExpiresAt: jwt.NewNumericDate(expiresAt),
			IssuedAt:  jwt.NewNumericDate(now),
		},
	}

	token := jwt.NewWithClaims(s.config.SigningMethod, claims)
	tokenString, err := token.SignedString(s.config.SigningKey)
	if err != nil {
		return nil, err
	}

	return &identity.Session{
		ID:         tokenString,
		IdentityID: fmt.Sprintf("%v", identityID),
		ExpiresAt:  expiresAt,
		IssuedAt:   now,
		Active:     true,
	}, nil
}

func (s *JWTStrategy) Validate(sessionID any) (*identity.Session, error) {
	tokenString, ok := sessionID.(string)
	if !ok {
		return nil, fmt.Errorf("invalid token format")
	}

	token, err := jwt.ParseWithClaims(tokenString, &JWTClaims{}, func(token *jwt.Token) (interface{}, error) {
		// Verify method algorithm matches config
		if token.Method.Alg() != s.config.SigningMethod.Alg() {
			return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
		}
		return s.config.VerifyingKey, nil
	})

	if err != nil {
		return nil, err
	}

	if claims, ok := token.Claims.(*JWTClaims); ok && token.Valid {
		return &identity.Session{
			ID:         tokenString,
			IdentityID: claims.Subject,
			ExpiresAt:  claims.ExpiresAt.Time,
			IssuedAt:   claims.IssuedAt.Time,
			Active:     true,
		}, nil
	}

	return nil, fmt.Errorf("invalid token")
}

func (s *JWTStrategy) Delete(sessionID any) error {
	// Stateless, nothing to delete on server side.
	return nil
}

func NewSession(sessionID, identityID any) *identity.Session {
	return &identity.Session{
		ID:         fmt.Sprintf("%v", sessionID),
		IdentityID: fmt.Sprintf("%v", identityID),
		ExpiresAt:  time.Now().Add(24 * time.Hour),
		IssuedAt:   time.Now(),
		Active:     true,
	}
}
